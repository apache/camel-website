<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<xs:schema elementFormDefault="qualified" version="1.0" targetNamespace="http://activemq.apache.org/camel/schema/spring" xmlns:tns="http://activemq.apache.org/camel/schema/spring" xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <xs:element name="aggregator" type="tns:aggregatorType"/>

  <xs:element name="artixDS" type="tns:artixDSDataFormat"/>

  <xs:element name="batchResequencerConfig" type="tns:batchResequencerConfig"/>

  <xs:element name="bean" type="tns:beanRef"/>

  <xs:element name="beanPostProcessor" type="tns:camelBeanPostProcessor"/>

  <xs:element name="beanshell" type="tns:beanShellExpression"/>

  <xs:element name="camelContext" type="tns:camelContextFactoryBean"/>

  <xs:element name="catch" type="tns:catchType"/>

  <xs:element name="choice" type="tns:choiceType"/>

  <xs:element name="constant" type="tns:constantExpression"/>

  <xs:element name="convertBodyTo" type="tns:convertBodyType"/>

  <xs:element name="csv" type="tns:csvDataFormat"/>

  <xs:element name="dataFormats" type="tns:dataFormatsType"/>

  <xs:element name="delayer" type="tns:delayerType"/>

  <xs:element name="description" type="tns:description"/>

  <xs:element name="el" type="tns:elExpression"/>

  <xs:element name="endpoint" type="tns:endpointFactoryBean"/>

  <xs:element name="export" type="tns:camelServiceExporterType"/>

  <xs:element name="expression" nillable="true" type="xs:anyType"/>

  <xs:element name="expressionType" type="tns:expressionType"/>

  <xs:element name="filter" type="tns:filterType"/>

  <xs:element name="finally" type="tns:finallyType"/>

  <xs:element name="flatpack" type="tns:flatpackDataFormat"/>

  <xs:element name="from" type="tns:fromType"/>

  <xs:element name="groovy" type="tns:groovyExpression"/>

  <xs:element name="handleFault" type="tns:handleFaultType"/>

  <xs:element name="header" type="tns:headerExpression"/>

  <xs:element name="hl7" type="tns:hl7DataFormat"/>

  <xs:element name="idempotentConsumer" type="tns:idempotentConsumerType"/>

  <xs:element name="inOnly" type="tns:inOnlyType"/>

  <xs:element name="inOut" type="tns:inOutType"/>

  <xs:element name="intercept" type="tns:interceptType"/>

  <xs:element name="interceptor" type="tns:interceptorRef"/>

  <xs:element name="javaScript" type="tns:javaScriptExpression"/>

  <xs:element name="jaxb" type="tns:jaxbDataFormat"/>

  <xs:element name="jmxAgent" type="tns:camelJMXAgentType"/>

  <xs:element name="json" type="tns:jsonDataFormat"/>

  <xs:element name="jxpath" type="tns:jxPathExpression"/>

  <xs:element name="loadBalance" type="tns:loadBalanceType"/>

  <xs:element name="loop" type="tns:loopType"/>

  <xs:element name="marshal" type="tns:marshalType"/>

  <xs:element name="methodCall" type="tns:methodCallExpression"/>

  <xs:element name="multicast" type="tns:multicastType"/>

  <xs:element name="ognl" type="tns:ognlExpression"/>

  <xs:element name="onException" type="tns:exceptionType"/>

  <xs:element name="otherwise" type="tns:otherwiseType"/>

  <xs:element name="php" type="tns:phpExpression"/>

  <xs:element name="pipeline" type="tns:pipelineType"/>

  <xs:element name="policy" type="tns:policyRef"/>

  <xs:element name="proceed" type="tns:proceedType"/>

  <xs:element name="process" type="tns:processorRef"/>

  <xs:element name="proxy" type="tns:camelProxyFactoryType"/>

  <xs:element name="python" type="tns:pythonExpression"/>

  <xs:element name="random" type="tns:randomLoadBalanceStrategy"/>

  <xs:element name="recipientList" type="tns:recipientListType"/>

  <xs:element name="redeliveryPolicy" type="tns:redeliveryPolicyType"/>

  <xs:element name="removeHeader" type="tns:removeHeaderType"/>

  <xs:element name="removeProperty" type="tns:removePropertyType"/>

  <xs:element name="resequencer" type="tns:resequencerType"/>

  <xs:element name="roundRobin" type="tns:roundRobinLoadBalanceStrategy"/>

  <xs:element name="route" type="tns:routeType"/>

  <xs:element name="routeBuilderRef" type="tns:routeBuilderRef"/>

  <xs:element name="routes" type="tns:routesType"/>

  <xs:element name="routingSlip" type="tns:routingSlipType"/>

  <xs:element name="ruby" type="tns:rubyExpression"/>

  <xs:element name="serialization" type="tns:serializationDataFormat"/>

  <xs:element name="serviceActivation" type="tns:serviceActivationType"/>

  <xs:element name="setBody" type="tns:setBodyType"/>

  <xs:element name="setExchangePattern" type="tns:setExchangePatternType"/>

  <xs:element name="setHeader" type="tns:setHeaderType"/>

  <xs:element name="setOutHeader" type="tns:setOutHeaderType"/>

  <xs:element name="setProperty" type="tns:setPropertyType"/>

  <xs:element name="simple" type="tns:simpleExpression"/>

  <xs:element name="splitter" type="tns:splitterType"/>

  <xs:element name="sql" type="tns:sqlExpression"/>

  <xs:element name="sticky" type="tns:stickyLoadBalanceStrategy"/>

  <xs:element name="streamResequencerConfig" type="tns:streamResequencerConfig"/>

  <xs:element name="string" type="tns:stringDataFormat"/>

  <xs:element name="template" type="tns:camelTemplateFactoryBean"/>

  <xs:element name="thread" type="tns:threadType"/>

  <xs:element name="throttler" type="tns:throttlerType"/>

  <xs:element name="throwFault" type="tns:throwFaultType"/>

  <xs:element name="tidyMarkup" type="tns:tidyMarkupDataFormat"/>

  <xs:element name="to" type="tns:toType"/>

  <xs:element name="topic" type="tns:topicLoadBalanceStrategy"/>

  <xs:element name="transform" type="tns:transformType"/>

  <xs:element name="try" type="tns:tryType"/>

  <xs:element name="unmarshal" type="tns:unmarshalType"/>

  <xs:element name="when" type="tns:whenType"/>

  <xs:element name="xmlBeans" type="tns:xmlBeansDataFormat"/>

  <xs:element name="xpath" type="tns:xPathExpression"/>

  <xs:element name="xquery" type="tns:xQueryExpression"/>

  <xs:element name="xstream" type="tns:xStreamDataFormat"/>

  <xs:element name="zip" type="tns:zipDataFormat"/>

  <xs:complexType name="aggregatorType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence>
          <xs:element name="completedPredicate" type="tns:expressionSubElementType" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="batchSize" type="xs:int"/>
        <xs:attribute name="outBatchSize" type="xs:int"/>
        <xs:attribute name="batchTimeout" type="xs:long"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
        <xs:attribute name="collectionRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="expressionNode">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence>
          <xs:choice maxOccurs="1" minOccurs="1">
            <xs:element ref="tns:expressionType"/>
            <xs:element ref="tns:beanshell"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:el"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:jxpath"/>
            <xs:element ref="tns:javaScript"/>
            <xs:element ref="tns:expression"/>
            <xs:element ref="tns:methodCall"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:php"/>
            <xs:element ref="tns:python"/>
            <xs:element ref="tns:ruby"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:sql"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregator"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:catch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delayer"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:finally"/>
            <xs:element ref="tns:handleFault"/>
            <xs:element ref="tns:interceptor"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:proceed"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequencer"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:splitter"/>
            <xs:element ref="tns:thread"/>
            <xs:element ref="tns:throttler"/>
            <xs:element ref="tns:throwFault"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:try"/>
            <xs:element ref="tns:unmarshal"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="processorType" abstract="true">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedType">
        <xs:sequence/>
        <xs:attribute name="errorHandlerRef" type="xs:string"/>
        <xs:attribute name="inheritErrorHandler" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="optionalIdentifiedType" abstract="true">
    <xs:sequence>
      <xs:element ref="tns:description" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="id" type="xs:ID"/>
  </xs:complexType>

  <xs:complexType name="expressionSubElementType">
    <xs:sequence>
      <xs:choice maxOccurs="1" minOccurs="1">
        <xs:element ref="tns:expressionType"/>
        <xs:element ref="tns:beanshell"/>
        <xs:element ref="tns:constant"/>
        <xs:element ref="tns:el"/>
        <xs:element ref="tns:groovy"/>
        <xs:element ref="tns:header"/>
        <xs:element ref="tns:jxpath"/>
        <xs:element ref="tns:javaScript"/>
        <xs:element ref="tns:expression"/>
        <xs:element ref="tns:methodCall"/>
        <xs:element ref="tns:ognl"/>
        <xs:element ref="tns:php"/>
        <xs:element ref="tns:python"/>
        <xs:element ref="tns:ruby"/>
        <xs:element ref="tns:simple"/>
        <xs:element ref="tns:sql"/>
        <xs:element ref="tns:xpath"/>
        <xs:element ref="tns:xquery"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="expressionType">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="id" type="xs:ID"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="description">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="lang" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="beanRef">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string"/>
        <xs:attribute name="method" type="xs:string"/>
        <xs:attribute name="beanType" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="outputType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregator"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:catch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delayer"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:finally"/>
            <xs:element ref="tns:handleFault"/>
            <xs:element ref="tns:interceptor"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:proceed"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequencer"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:splitter"/>
            <xs:element ref="tns:thread"/>
            <xs:element ref="tns:throttler"/>
            <xs:element ref="tns:throwFault"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:try"/>
            <xs:element ref="tns:unmarshal"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="catchType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence>
          <xs:element name="exception" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregator"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:catch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delayer"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:finally"/>
            <xs:element ref="tns:handleFault"/>
            <xs:element ref="tns:interceptor"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:proceed"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequencer"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:splitter"/>
            <xs:element ref="tns:thread"/>
            <xs:element ref="tns:throttler"/>
            <xs:element ref="tns:throwFault"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:try"/>
            <xs:element ref="tns:unmarshal"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="choiceType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence>
          <xs:element ref="tns:when" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:otherwise" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="whenType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="otherwiseType">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="convertBodyType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence/>
        <xs:attribute name="type" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="delayerType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence>
          <xs:element name="delay" type="xs:long" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="exceptionType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence>
          <xs:element name="exception" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element name="onWhen" type="tns:whenType" minOccurs="0"/>
          <xs:element ref="tns:redeliveryPolicy" minOccurs="0"/>
          <xs:element name="handled" type="tns:expressionSubElementType" minOccurs="0"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregator"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:catch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delayer"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:finally"/>
            <xs:element ref="tns:handleFault"/>
            <xs:element ref="tns:interceptor"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:proceed"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequencer"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:splitter"/>
            <xs:element ref="tns:thread"/>
            <xs:element ref="tns:throttler"/>
            <xs:element ref="tns:throwFault"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:try"/>
            <xs:element ref="tns:unmarshal"/>
          </xs:choice>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="redeliveryPolicyType">
    <xs:attribute name="ref" type="xs:string"/>
    <xs:attribute name="maximumRedeliveries" type="xs:int"/>
    <xs:attribute name="initialRedeliveryDelay" type="xs:long"/>
    <xs:attribute name="backOffMultiplier" type="xs:double"/>
    <xs:attribute name="useExponentialBackOff" type="xs:boolean"/>
    <xs:attribute name="collisionAvoidanceFactor" type="xs:double"/>
    <xs:attribute name="useCollisionAvoidance" type="xs:boolean"/>
    <xs:attribute name="maximumRedeliveryDelay" type="xs:long"/>
    <xs:attribute name="retriesExhaustedLogLevel" type="tns:loggingLevel"/>
    <xs:attribute name="retryAttemptedLogLevel" type="tns:loggingLevel"/>
  </xs:complexType>

  <xs:complexType name="filterType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="finallyType">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="fromType">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedType">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="handleFaultType">
    <xs:complexContent>
      <xs:extension base="tns:interceptorRef">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interceptorRef">
    <xs:complexContent>
      <xs:extension base="tns:interceptorType">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interceptorType" abstract="true">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="idempotentConsumerType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="messageIdRepositoryRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="identifiedType" abstract="true">
    <xs:attribute name="id" type="xs:ID"/>
  </xs:complexType>

  <xs:complexType name="inOnlyType">
    <xs:complexContent>
      <xs:extension base="tns:sendType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="sendType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="inOutType">
    <xs:complexContent>
      <xs:extension base="tns:sendType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="interceptType">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence>
          <xs:element name="stop" type="xs:string" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loadBalanceType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:roundRobin"/>
            <xs:element ref="tns:random"/>
            <xs:element ref="tns:sticky"/>
            <xs:element ref="tns:topic"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregator"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:catch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delayer"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:finally"/>
            <xs:element ref="tns:handleFault"/>
            <xs:element ref="tns:interceptor"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:proceed"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequencer"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:splitter"/>
            <xs:element ref="tns:thread"/>
            <xs:element ref="tns:throttler"/>
            <xs:element ref="tns:throwFault"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:try"/>
            <xs:element ref="tns:unmarshal"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="roundRobinLoadBalanceStrategy">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancerType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loadBalancerType">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="randomLoadBalanceStrategy">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancerType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="stickyLoadBalanceStrategy">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancerType">
        <xs:sequence>
          <xs:element name="expression" type="tns:expressionType"/>
          <xs:element name="loadBalancer" type="tns:loadBalancerType" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="topicLoadBalanceStrategy">
    <xs:complexContent>
      <xs:extension base="tns:loadBalancerType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loopType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="marshalType">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:artixDS"/>
            <xs:element ref="tns:csv"/>
            <xs:element ref="tns:flatpack"/>
            <xs:element ref="tns:hl7"/>
            <xs:element ref="tns:jaxb"/>
            <xs:element ref="tns:serialization"/>
            <xs:element ref="tns:string"/>
            <xs:element ref="tns:xmlBeans"/>
            <xs:element ref="tns:xstream"/>
            <xs:element ref="tns:zip"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="artixDSDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormatType">
        <xs:sequence/>
        <xs:attribute name="elementTypeName" type="xs:string"/>
        <xs:attribute name="format" type="xs:string"/>
        <xs:attribute name="elementType" type="xs:string"/>
        <xs:attribute name="contentType" type="tns:artixDSContentType"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="dataFormatType">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="csvDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormatType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="flatpackDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormatType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="hl7DataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormatType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jaxbDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormatType">
        <xs:sequence/>
        <xs:attribute name="contextPath" type="xs:string"/>
        <xs:attribute name="prettyPrint" type="xs:boolean"/>
        <xs:attribute name="ignoreJAXBElement" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="serializationDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormatType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="stringDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormatType">
        <xs:sequence/>
        <xs:attribute name="charset" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xmlBeansDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormatType">
        <xs:sequence/>
        <xs:attribute name="prettyPrint" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="xStreamDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormatType">
        <xs:sequence/>
        <xs:attribute name="prettyPrint" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="zipDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormatType">
        <xs:sequence/>
        <xs:attribute name="compressionLevel" type="xs:int" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="multicastType">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
        <xs:attribute name="parallelProcessing" type="xs:boolean"/>
        <xs:attribute name="strategyRef" type="xs:string"/>
        <xs:attribute name="threadPoolRef" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="nodeFactory"/>

  <xs:complexType name="pipelineType">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="policyRef">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="proceedType">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="processorRef">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="recipientListType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="delimiter" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="removeHeaderType">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
        <xs:attribute name="headerName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="removePropertyType">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
        <xs:attribute name="propertyName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="resequencerType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:expressionType"/>
            <xs:element ref="tns:beanshell"/>
            <xs:element ref="tns:constant"/>
            <xs:element ref="tns:el"/>
            <xs:element ref="tns:groovy"/>
            <xs:element ref="tns:header"/>
            <xs:element ref="tns:jxpath"/>
            <xs:element ref="tns:javaScript"/>
            <xs:element ref="tns:expression"/>
            <xs:element ref="tns:methodCall"/>
            <xs:element ref="tns:ognl"/>
            <xs:element ref="tns:php"/>
            <xs:element ref="tns:python"/>
            <xs:element ref="tns:ruby"/>
            <xs:element ref="tns:simple"/>
            <xs:element ref="tns:sql"/>
            <xs:element ref="tns:xpath"/>
            <xs:element ref="tns:xquery"/>
          </xs:choice>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregator"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:catch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delayer"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:finally"/>
            <xs:element ref="tns:handleFault"/>
            <xs:element ref="tns:interceptor"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:proceed"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequencer"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:splitter"/>
            <xs:element ref="tns:thread"/>
            <xs:element ref="tns:throttler"/>
            <xs:element ref="tns:throwFault"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:try"/>
            <xs:element ref="tns:unmarshal"/>
          </xs:choice>
          <xs:element name="batch-config" type="tns:batchResequencerConfig" minOccurs="0"/>
          <xs:element name="stream-config" type="tns:streamResequencerConfig" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="batchResequencerConfig">
    <xs:attribute name="batchSize" type="xs:int"/>
    <xs:attribute name="batchTimeout" type="xs:long"/>
  </xs:complexType>

  <xs:complexType name="streamResequencerConfig">
    <xs:attribute name="capacity" type="xs:int"/>
    <xs:attribute name="timeout" type="xs:long"/>
  </xs:complexType>

  <xs:complexType name="routeBuilderRef">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="ref" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routeType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence>
          <xs:element ref="tns:from" maxOccurs="unbounded" minOccurs="0"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregator"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:catch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delayer"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:finally"/>
            <xs:element ref="tns:handleFault"/>
            <xs:element ref="tns:interceptor"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:proceed"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequencer"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:splitter"/>
            <xs:element ref="tns:thread"/>
            <xs:element ref="tns:throttler"/>
            <xs:element ref="tns:throwFault"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:try"/>
            <xs:element ref="tns:unmarshal"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="group" type="xs:string"/>
        <xs:attribute name="streamCaching" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="routesType">
    <xs:complexContent>
      <xs:extension base="tns:optionalIdentifiedType">
        <xs:sequence>
          <xs:element ref="tns:route" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:serviceActivation" maxOccurs="unbounded" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="inheritErrorHandlerFlag" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="serviceActivationType">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded" minOccurs="0">
        <xs:element ref="tns:expressionType"/>
        <xs:element ref="tns:beanshell"/>
        <xs:element ref="tns:constant"/>
        <xs:element ref="tns:el"/>
        <xs:element ref="tns:groovy"/>
        <xs:element ref="tns:header"/>
        <xs:element ref="tns:jxpath"/>
        <xs:element ref="tns:javaScript"/>
        <xs:element ref="tns:expression"/>
        <xs:element ref="tns:methodCall"/>
        <xs:element ref="tns:ognl"/>
        <xs:element ref="tns:php"/>
        <xs:element ref="tns:python"/>
        <xs:element ref="tns:ruby"/>
        <xs:element ref="tns:simple"/>
        <xs:element ref="tns:sql"/>
        <xs:element ref="tns:xpath"/>
        <xs:element ref="tns:xquery"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="group" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="routingSlipType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence/>
        <xs:attribute name="headerName" type="xs:string"/>
        <xs:attribute name="uriDelimiter" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setBodyType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setExchangePatternType">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
        <xs:attribute name="pattern" type="tns:exchangePattern" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setHeaderType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="headerName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setOutHeaderType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="headerName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="setPropertyType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="propertyName" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="splitterType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
        <xs:attribute name="parallelProcessing" type="xs:boolean"/>
        <xs:attribute name="threadPoolExecutorRef" type="xs:string"/>
        <xs:attribute name="streaming" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="threadType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregator"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:catch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delayer"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:finally"/>
            <xs:element ref="tns:handleFault"/>
            <xs:element ref="tns:interceptor"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:proceed"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequencer"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:splitter"/>
            <xs:element ref="tns:thread"/>
            <xs:element ref="tns:throttler"/>
            <xs:element ref="tns:throwFault"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:try"/>
            <xs:element ref="tns:unmarshal"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="coreSize" type="xs:int"/>
        <xs:attribute name="daemon" type="xs:boolean"/>
        <xs:attribute name="keepAliveTime" type="xs:long"/>
        <xs:attribute name="maxSize" type="xs:int"/>
        <xs:attribute name="name" type="xs:string"/>
        <xs:attribute name="priority" type="xs:int"/>
        <xs:attribute name="stackSize" type="xs:long"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="throttlerType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:aggregator"/>
            <xs:element ref="tns:bean"/>
            <xs:element ref="tns:catch"/>
            <xs:element ref="tns:choice"/>
            <xs:element ref="tns:when"/>
            <xs:element ref="tns:otherwise"/>
            <xs:element ref="tns:convertBodyTo"/>
            <xs:element ref="tns:delayer"/>
            <xs:element ref="tns:onException"/>
            <xs:element ref="tns:filter"/>
            <xs:element ref="tns:finally"/>
            <xs:element ref="tns:handleFault"/>
            <xs:element ref="tns:interceptor"/>
            <xs:element ref="tns:idempotentConsumer"/>
            <xs:element ref="tns:inOnly"/>
            <xs:element ref="tns:inOut"/>
            <xs:element ref="tns:intercept"/>
            <xs:element ref="tns:loadBalance"/>
            <xs:element ref="tns:loop"/>
            <xs:element ref="tns:marshal"/>
            <xs:element ref="tns:multicast"/>
            <xs:element ref="tns:pipeline"/>
            <xs:element ref="tns:policy"/>
            <xs:element ref="tns:proceed"/>
            <xs:element ref="tns:process"/>
            <xs:element ref="tns:recipientList"/>
            <xs:element ref="tns:removeHeader"/>
            <xs:element ref="tns:removeProperty"/>
            <xs:element ref="tns:resequencer"/>
            <xs:element ref="tns:route"/>
            <xs:element ref="tns:routingSlip"/>
            <xs:element ref="tns:setBody"/>
            <xs:element ref="tns:setExchangePattern"/>
            <xs:element ref="tns:setHeader"/>
            <xs:element ref="tns:setOutHeader"/>
            <xs:element ref="tns:setProperty"/>
            <xs:element ref="tns:splitter"/>
            <xs:element ref="tns:thread"/>
            <xs:element ref="tns:throttler"/>
            <xs:element ref="tns:throwFault"/>
            <xs:element ref="tns:to"/>
            <xs:element ref="tns:transform"/>
            <xs:element ref="tns:try"/>
            <xs:element ref="tns:unmarshal"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="maximumRequestsPerPeriod" type="xs:long"/>
        <xs:attribute name="timePeriodMillis" type="xs:long" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="throwFaultType">
    <xs:complexContent>
      <xs:extension base="tns:processorType">
        <xs:sequence/>
        <xs:attribute name="faultRef" type="xs:string" use="required"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="toType">
    <xs:complexContent>
      <xs:extension base="tns:sendType">
        <xs:sequence/>
        <xs:attribute name="pattern" type="tns:exchangePattern"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="transformType">
    <xs:complexContent>
      <xs:extension base="tns:expressionNode">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="tryType">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="unmarshalType">
    <xs:complexContent>
      <xs:extension base="tns:outputType">
        <xs:sequence>
          <xs:choice minOccurs="0">
            <xs:element ref="tns:artixDS"/>
            <xs:element ref="tns:csv"/>
            <xs:element ref="tns:flatpack"/>
            <xs:element ref="tns:hl7"/>
            <xs:element ref="tns:jaxb"/>
            <xs:element ref="tns:serialization"/>
            <xs:element ref="tns:string"/>
            <xs:element ref="tns:tidyMarkup"/>
            <xs:element ref="tns:xmlBeans"/>
            <xs:element ref="tns:xstream"/>
            <xs:element ref="tns:zip"/>
          </xs:choice>
        </xs:sequence>
        <xs:attribute name="ref" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="tidyMarkupDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormatType">
        <xs:sequence/>
        <xs:attribute name="dataObjectType" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="dataFormatsType">
    <xs:sequence>
      <xs:choice maxOccurs="unbounded" minOccurs="0">
        <xs:element ref="tns:artixDS"/>
        <xs:element ref="tns:csv"/>
        <xs:element ref="tns:flatpack"/>
        <xs:element ref="tns:hl7"/>
        <xs:element ref="tns:jaxb"/>
        <xs:element ref="tns:json"/>
        <xs:element ref="tns:serialization"/>
        <xs:element ref="tns:string"/>
        <xs:element ref="tns:tidyMarkup"/>
        <xs:element ref="tns:xmlBeans"/>
        <xs:element ref="tns:xstream"/>
        <xs:element ref="tns:zip"/>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="jsonDataFormat">
    <xs:complexContent>
      <xs:extension base="tns:dataFormatType">
        <xs:sequence/>
        <xs:attribute name="prettyPrint" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="beanShellExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="constantExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="elExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="groovyExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="headerExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="jxPathExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="javaScriptExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="languageExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType">
        <xs:attribute name="language" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="methodCallExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType">
        <xs:attribute name="bean" type="xs:string"/>
        <xs:attribute name="method" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="namespaceAwareExpression" abstract="true">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="ognlExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="phpExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="pythonExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="rubyExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="simpleExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="sqlExpression">
    <xs:simpleContent>
      <xs:extension base="tns:expressionType"/>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="xPathExpression">
    <xs:simpleContent>
      <xs:extension base="tns:namespaceAwareExpression">
        <xs:attribute name="resultType" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="xQueryExpression">
    <xs:simpleContent>
      <xs:extension base="tns:namespaceAwareExpression">
        <xs:attribute name="type" type="xs:string"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:complexType name="camelBeanPostProcessor"/>

  <xs:complexType name="camelContextFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence>
          <xs:element name="package" type="xs:string" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:jmxAgent" minOccurs="0"/>
          <xs:choice maxOccurs="unbounded" minOccurs="0">
            <xs:element ref="tns:beanPostProcessor"/>
            <xs:element ref="tns:template"/>
            <xs:element ref="tns:proxy"/>
            <xs:element ref="tns:export"/>
          </xs:choice>
          <xs:element ref="tns:routeBuilderRef" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:endpoint" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:dataFormats" minOccurs="0"/>
          <xs:element ref="tns:intercept" maxOccurs="unbounded" minOccurs="0"/>
          <xs:element ref="tns:route" maxOccurs="unbounded" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="useJmx" type="xs:boolean"/>
        <xs:attribute name="autowireRouteBuilders" type="xs:boolean"/>
        <xs:attribute name="trace" type="xs:boolean"/>
        <xs:attribute name="delay" type="xs:long"/>
        <xs:attribute name="errorHandlerRef" type="xs:string"/>
        <xs:attribute name="shouldStartContext" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelJMXAgentType">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="disabled" type="xs:boolean"/>
        <xs:attribute name="registryPort" type="xs:int"/>
        <xs:attribute name="connectorPort" type="xs:int"/>
        <xs:attribute name="mbeanServerDefaultDomain" type="xs:string"/>
        <xs:attribute name="mbeanObjectDomainName" type="xs:string"/>
        <xs:attribute name="serviceUrlPath" type="xs:string"/>
        <xs:attribute name="createConnector" type="xs:boolean"/>
        <xs:attribute name="usePlatformMBeanServer" type="xs:boolean"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelTemplateFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="defaultEndpoint" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelProxyFactoryType">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="serviceUrl" type="xs:string"/>
        <xs:attribute name="serviceInterface" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="camelServiceExporterType">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
        <xs:attribute name="serviceRef" type="xs:string"/>
        <xs:attribute name="serviceInterface" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="endpointFactoryBean">
    <xs:complexContent>
      <xs:extension base="tns:identifiedType">
        <xs:sequence/>
        <xs:attribute name="uri" type="xs:string"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:simpleType name="exchangePattern">
    <xs:restriction base="xs:string">
      <xs:enumeration value="OutOptionalIn"/>
      <xs:enumeration value="OutIn"/>
      <xs:enumeration value="RobustOutOnly"/>
      <xs:enumeration value="OutOnly"/>
      <xs:enumeration value="InOptionalOut"/>
      <xs:enumeration value="InOut"/>
      <xs:enumeration value="RobustInOnly"/>
      <xs:enumeration value="InOnly"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="loggingLevel">
    <xs:restriction base="xs:string">
      <xs:enumeration value="OFF"/>
      <xs:enumeration value="WARN"/>
      <xs:enumeration value="TRACE"/>
      <xs:enumeration value="INFO"/>
      <xs:enumeration value="FATAL"/>
      <xs:enumeration value="ERROR"/>
      <xs:enumeration value="DEBUG"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="artixDSContentType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="TagValuePair"/>
      <xs:enumeration value="Sax"/>
      <xs:enumeration value="Xml"/>
      <xs:enumeration value="Java"/>
      <xs:enumeration value="Text"/>
      <xs:enumeration value="Binary"/>
      <xs:enumeration value="Auto"/>
      <xs:enumeration value="Default"/>
    </xs:restriction>
  </xs:simpleType>
</xs:schema>

